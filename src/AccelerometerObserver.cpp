//
//
//  Generated by StarUML(tm) C++ Add-In
//
//  @ Project : Untitled
//  @ File Name : AccelerometerObserver.cpp
//  @ Date : 7/14/2015
//  @ Author : 
//
//

#include "AccelerometerObserver.h"
#include "AccelerometerSubject.h"
#include <Arduino.h>
//#include "StringConsts.h"
#include "Debug.h"

AccelerometerObserver::AccelerometerObserver( AccelerometerSubject * subject, float alpha) :
	Observer(subject), LPFalpha(alpha)
{
}

void AccelerometerObserver::Update() {

	AccelerometerSubject * subj = (AccelerometerSubject *) mySubject;
	int retVal = subj->getData(&rawCart.accX, &rawCart.accY, &rawCart.accZ);

#undef ACCELEROMETER_OBSERVER_DEBUG
#ifdef ACCELEROMETER_OBSERVER_DEBUG
	debugPrint(F("AccelerometerObserver Update: x y z ret "));
	debugPrint(rawCart.accX); debugPrint(SPACE);
	debugPrint(rawCart.accY); debugPrint(SPACE);
	debugPrint(rawCart.accZ); debugPrint(SPACE);
	debugPrint(retVal); debugPrint(SPACE);
	debugPrintln();
#endif
	// TBD - check retVal, decide what to do on overwrite or timeout, etc.
	//
	updateCart();
	//updateEuler();
	//call internal updateCart() to save the raw and filtered data
	//call internal updateEuler() to convert to angles and save raw and filtered
}

void AccelerometerObserver::getCart(Cartesian * cart, int raw)
{
	if (raw) {
		*cart = rawCart;
	} else {
		*cart = filtCart;
	}
}

/*
   void AccelerometerObserver::getEuler(EulerAngles * euler){
 *euler = filtEuler;
 }
 */

void AccelerometerObserver::updateCart() {
	// we have new raw data, update filtered values
	filtCart.accX = filtCart.accX * (1-LPFalpha) + rawCart.accX * LPFalpha;
	filtCart.accY = filtCart.accY * (1-LPFalpha) + rawCart.accY * LPFalpha;
	filtCart.accZ = filtCart.accZ * (1-LPFalpha) + rawCart.accZ * LPFalpha;
}

/*
   void AccelerometerObserver::updateEuler() {
// save raw data, perform filtering, save filtered data

}
*/
